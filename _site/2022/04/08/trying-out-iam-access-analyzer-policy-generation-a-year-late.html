<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Trying out IAM Access Analyzer policy generation (a year late) | Ryan Persaud’s blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Trying out IAM Access Analyzer policy generation (a year late)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt; &lt;/p&gt; Since early on in my journey with AWS, I’ve been looking for tools to assist me in creating least privilege policies.  Many online examples and actual tool documentation provide overly permissive policies, so it’s important to analyze them before deploying them in production (or even DEV, depending on the permission!).  One tool that I experimented with a few years ago was DUO Labs’ CloudTracker.  I used it with another engineer, Harry, to try and reduce the set of S3 permissions granted to GitLab’s role since the documentation recommended (at the time, at least) granting S3:*.  I also used it to get 90% of the permissions for a Terraform role that engineers could assume when applying their TF*. So when AWS announced IAM Access Analyzer policy generation I was excited to try it out.  Not having to install and run an external tool and worry about my Athena spend was definitely attractive. A year later, and  I finally got around to trying it out this week at work, so I figured I’d write a brief post describing my experience.  Note, the example provided in this post is from my personal AWS account. First, I created a role, lambda-aa-test,  with an inline policy that granted the role permission to call GetFunction: { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;lambda:GetFunction&quot;, &quot;Resource&quot;: &quot;*&quot; } ] } Then I assumed lambda-aa-test and called get-function on a Lambda function in my account.  Interestingly, CloudTrail records this as GetFunction20150331v2 which caused some confusion when I was attempting to verify that the call had propagated to CloudTrail.  Next, I clicked the button to ‘Generate Policy’ and waited a couple of minutes while the analyzer did its thing.  Here’s the generated policy: { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;sts:GetCallerIdentity&quot;, &quot;Resource&quot;: &quot;*&quot; }, { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;lambda:GetFunction&quot;, &quot;Resource&quot;: &quot;arn:aws:lambda:${Region}:${Account}:function:${FunctionName}&quot; } ] } sts:GetCallerIdentity is not a mistake - I did call that after assuming the role to ensure I was who I thought I was.  And you can see that lambda:GetFunction was also included as expected.  However, the resource is a templated ARN that can be filled in by the user.  This is useful for understanding what Resource the Action can be applied to (and the expected ARN format), but it isn’t super helpful in cases where there are a number of possible resources and we want to narrow down which ones an action can be performed on.  For example, if I had twenty Lambda functions, but I only ever call GetFunction on MyFunction, this generated policy would not help me limit GetFunction to MyFunction.  IIRC, this was also a  limitation of CloudTracker when I used it. * I should note that even with the reduced permissions, an attacker could still escalate their privileges by using the terraform role to create a policy with whatever permissions they desired.  Permission Boundaries can limit the effective permissions of policies created by the terraform role, but implementing PBs can be complex and difficult to debug. &lt;/body&gt;&lt;/html&gt;" />
<meta property="og:description" content="&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt; &lt;/p&gt; Since early on in my journey with AWS, I’ve been looking for tools to assist me in creating least privilege policies.  Many online examples and actual tool documentation provide overly permissive policies, so it’s important to analyze them before deploying them in production (or even DEV, depending on the permission!).  One tool that I experimented with a few years ago was DUO Labs’ CloudTracker.  I used it with another engineer, Harry, to try and reduce the set of S3 permissions granted to GitLab’s role since the documentation recommended (at the time, at least) granting S3:*.  I also used it to get 90% of the permissions for a Terraform role that engineers could assume when applying their TF*. So when AWS announced IAM Access Analyzer policy generation I was excited to try it out.  Not having to install and run an external tool and worry about my Athena spend was definitely attractive. A year later, and  I finally got around to trying it out this week at work, so I figured I’d write a brief post describing my experience.  Note, the example provided in this post is from my personal AWS account. First, I created a role, lambda-aa-test,  with an inline policy that granted the role permission to call GetFunction: { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;lambda:GetFunction&quot;, &quot;Resource&quot;: &quot;*&quot; } ] } Then I assumed lambda-aa-test and called get-function on a Lambda function in my account.  Interestingly, CloudTrail records this as GetFunction20150331v2 which caused some confusion when I was attempting to verify that the call had propagated to CloudTrail.  Next, I clicked the button to ‘Generate Policy’ and waited a couple of minutes while the analyzer did its thing.  Here’s the generated policy: { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;sts:GetCallerIdentity&quot;, &quot;Resource&quot;: &quot;*&quot; }, { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;lambda:GetFunction&quot;, &quot;Resource&quot;: &quot;arn:aws:lambda:${Region}:${Account}:function:${FunctionName}&quot; } ] } sts:GetCallerIdentity is not a mistake - I did call that after assuming the role to ensure I was who I thought I was.  And you can see that lambda:GetFunction was also included as expected.  However, the resource is a templated ARN that can be filled in by the user.  This is useful for understanding what Resource the Action can be applied to (and the expected ARN format), but it isn’t super helpful in cases where there are a number of possible resources and we want to narrow down which ones an action can be performed on.  For example, if I had twenty Lambda functions, but I only ever call GetFunction on MyFunction, this generated policy would not help me limit GetFunction to MyFunction.  IIRC, this was also a  limitation of CloudTracker when I used it. * I should note that even with the reduced permissions, an attacker could still escalate their privileges by using the terraform role to create a policy with whatever permissions they desired.  Permission Boundaries can limit the effective permissions of policies created by the terraform role, but implementing PBs can be complex and difficult to debug. &lt;/body&gt;&lt;/html&gt;" />
<link rel="canonical" href="http://0.0.0.0:4000/2022/04/08/trying-out-iam-access-analyzer-policy-generation-a-year-late.html" />
<meta property="og:url" content="http://0.0.0.0:4000/2022/04/08/trying-out-iam-access-analyzer-policy-generation-a-year-late.html" />
<meta property="og:site_name" content="Ryan Persaud’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-04-08T20:25:11+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Trying out IAM Access Analyzer policy generation (a year late)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-08T20:25:11+00:00","datePublished":"2022-04-08T20:25:11+00:00","description":"&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt; &lt;/p&gt; Since early on in my journey with AWS, I’ve been looking for tools to assist me in creating least privilege policies.  Many online examples and actual tool documentation provide overly permissive policies, so it’s important to analyze them before deploying them in production (or even DEV, depending on the permission!).  One tool that I experimented with a few years ago was DUO Labs’ CloudTracker.  I used it with another engineer, Harry, to try and reduce the set of S3 permissions granted to GitLab’s role since the documentation recommended (at the time, at least) granting S3:*.  I also used it to get 90% of the permissions for a Terraform role that engineers could assume when applying their TF*. So when AWS announced IAM Access Analyzer policy generation I was excited to try it out.  Not having to install and run an external tool and worry about my Athena spend was definitely attractive. A year later, and  I finally got around to trying it out this week at work, so I figured I’d write a brief post describing my experience.  Note, the example provided in this post is from my personal AWS account. First, I created a role, lambda-aa-test,  with an inline policy that granted the role permission to call GetFunction: { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;lambda:GetFunction&quot;, &quot;Resource&quot;: &quot;*&quot; } ] } Then I assumed lambda-aa-test and called get-function on a Lambda function in my account.  Interestingly, CloudTrail records this as GetFunction20150331v2 which caused some confusion when I was attempting to verify that the call had propagated to CloudTrail.  Next, I clicked the button to ‘Generate Policy’ and waited a couple of minutes while the analyzer did its thing.  Here’s the generated policy: { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;sts:GetCallerIdentity&quot;, &quot;Resource&quot;: &quot;*&quot; }, { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;lambda:GetFunction&quot;, &quot;Resource&quot;: &quot;arn:aws:lambda:${Region}:${Account}:function:${FunctionName}&quot; } ] } sts:GetCallerIdentity is not a mistake - I did call that after assuming the role to ensure I was who I thought I was.  And you can see that lambda:GetFunction was also included as expected.  However, the resource is a templated ARN that can be filled in by the user.  This is useful for understanding what Resource the Action can be applied to (and the expected ARN format), but it isn’t super helpful in cases where there are a number of possible resources and we want to narrow down which ones an action can be performed on.  For example, if I had twenty Lambda functions, but I only ever call GetFunction on MyFunction, this generated policy would not help me limit GetFunction to MyFunction.  IIRC, this was also a  limitation of CloudTracker when I used it. * I should note that even with the reduced permissions, an attacker could still escalate their privileges by using the terraform role to create a policy with whatever permissions they desired.  Permission Boundaries can limit the effective permissions of policies created by the terraform role, but implementing PBs can be complex and difficult to debug. &lt;/body&gt;&lt;/html&gt;","headline":"Trying out IAM Access Analyzer policy generation (a year late)","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/2022/04/08/trying-out-iam-access-analyzer-policy-generation-a-year-late.html"},"url":"http://0.0.0.0:4000/2022/04/08/trying-out-iam-access-analyzer-policy-generation-a-year-late.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="Ryan Persaud&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Ryan Persaud&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Trying out IAM Access Analyzer policy generation (a year late)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-04-08T20:25:11+00:00" itemprop="datePublished">Apr 8, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<!-- wp:paragraph --><html><body></p>
<p>Since early on in my journey with AWS, I’ve been looking for tools to assist me in creating least privilege policies.  Many online examples and actual tool documentation provide overly permissive policies, so it’s important to analyze them before deploying them in production (or even DEV, depending on the permission!).  One tool that I experimented with a few years ago was DUO Labs’ <a href="https://github.com/duo-labs/cloudtracker">CloudTracker</a>.  I used it with another engineer, <a href="https://harryeldridge.com/">Harry</a>, to try and reduce the set of S3 permissions granted to GitLab’s role since the documentation recommended (at the time, at least) granting <code>S3:*</code>.  I also used it to get 90% of the permissions for a Terraform role that engineers could assume when applying their TF*.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>So when AWS <a href="https://aws.amazon.com/blogs/security/iam-access-analyzer-makes-it-easier-to-implement-least-privilege-permissions-by-generating-iam-policies-based-on-access-activity/">announced IAM Access Analyzer policy generation</a> I was excited to try it out.  Not having to install and run an external tool and worry about my Athena spend was definitely attractive. A year later, and  I finally got around to trying it out this week at work, so I figured I’d write a brief post describing my experience.  Note, the example provided in this post is from my personal AWS account.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>First, I created a role, <code>lambda-aa-test</code>,  with an inline policy that granted the role permission to call <code>GetFunction</code>:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:code --></p>
<pre class="wp-block-code"><code>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": "lambda:GetFunction",
            "Resource": "*"
        }
    ]
}</code></pre>
<p><!-- /wp:code --></p>
<p><!-- wp:paragraph --></p>
<p>Then I assumed <code>lambda-aa-test</code> and called <code>get-function</code> on a Lambda function in my account.  Interestingly, CloudTrail records this as <code>GetFunction20150331v2</code> which caused some confusion when I was attempting to verify that the call had propagated to CloudTrail.  Next, I clicked the button to ‘Generate Policy’ and waited a couple of minutes while the analyzer did its thing.  Here’s the generated policy:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:code --></p>
<pre class="wp-block-code"><code>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "sts:GetCallerIdentity",
            "Resource": "*"
        },
        {
        "Effect": "Allow",
            "Action": "lambda:GetFunction",
            "Resource": "arn:aws:lambda:${Region}:${Account}:function:${FunctionName}"
        }
    ]
}</code></pre>
<p><!-- /wp:code --></p>
<p><!-- wp:paragraph --></p>
<p><code>sts:GetCallerIdentity</code> is not a mistake - I did call that after assuming the role to ensure I was who I thought I was.  And you can see that <code>lambda:GetFunction</code> was also included as expected.  However, the resource is a templated ARN that can be filled in by the user.  This is useful for understanding what Resource the Action can be applied to (and the expected ARN format), but it isn’t super helpful in cases where there are a number of possible resources and we want to narrow down which ones an action can be performed on.  For example, if I had twenty Lambda functions, but I only ever call <code>GetFunction</code> on <code>MyFunction</code>, this generated policy would not help me limit <code>GetFunction </code>to <code>MyFunction</code>.  IIRC, this was also a  limitation of CloudTracker when I used it.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>* I should note that even with the reduced permissions, an attacker could still escalate their privileges by using the terraform role to create a policy with whatever permissions they desired.  <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permission Boundaries</a> can limit the effective permissions of policies created by the terraform role, but implementing PBs can be complex and difficult to debug.</p>
<p><!-- /wp:paragraph --><br />
</body></html></p>

  </div><a class="u-url" href="/2022/04/08/trying-out-iam-access-analyzer-policy-generation-a-year-late.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ryan Persaud&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ryan Persaud&#39;s blog</li><li><a class="u-email" href="mailto:ryan.persaud At Google's Email Service">ryan.persaud At Google's Email Service</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ryanpersaud"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ryanpersaud</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is apparently where all of my musings have ended up.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
