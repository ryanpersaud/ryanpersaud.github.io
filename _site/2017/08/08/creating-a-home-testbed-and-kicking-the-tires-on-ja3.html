<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Creating a Home Testbed, and Kicking the Tires on JA3 | Ryan Persaud’s blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Creating a Home Testbed, and Kicking the Tires on JA3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt; For a while now, I have wanted the ability to easily sniff my own packets.  Specifically, I&#39;ve wanted to be able to monitor all traffic entering and exiting my home network.  In the past, I&#39;ve turned old machines into transparent bridges and wired them in between my router and cable modem.  However, actually using these boxes was never quite as simple as I had hoped, and in the back of my mind I was always afraid that the bridge would be detected and hax0red.  I knew the easiest solution would be to upgrade from my army of cheap, unmanaged switches to a more expensive manged switch that supported port mirroring.  In July, I finally ordered a TP-Link switch that fit the bill.  I installed it the day it arrived, but I have not had a chance to try the more advanced features until this past weekend.  I figured I&#39;d use the opportunity to kick the tires on the JA3 SSL/TLS client fingerprinting scheme that some researchers at Salesforce have been working on. Out of the box, the switch has the IP address 192.168.0.1, so I had to put a machine on that network in order to configure the switch.  Word to the wise, updating the firmware reverts the switch&#39;s IP address to 192.168.0.1, so you may want to update before changing the IP.  Anyway, enabling port mirroring on the TP Link was straightforward, if inelegant (you get what you pay for).  One gotcha is that I had to select the mirroring port a second time before it &#39;stuck&#39; (see previous parenthetical note).  I mirrored the port that connects the switch to my router, and after some futzing with my Raspberry Pi&#39;s external USB network adapter and an ancient USB hub, I was in business: This setup is temporary and I hope to neaten it up at some point in the near future. JA3 parses client Hello SSL/TLS packets and extracts out fields to create a string that can be used to uniquely identify a client (a fingerprint).  Instead of passing around a potentially large string, an MD5 hash is calculated.  Since I only needed to capture Hello packets, I did a quick Google to find a tcpdump filter that would drop the rest of the traffic coming over the mirror port:  tcpdump -ni eth1 &quot;tcp port 443 and (tcp[((tcp[12] &amp; 0xf0) &gt;&gt; 2)] = 0x16)&quot; This filter actually grabs server Hellos too, but I can live with that for now.  I let the capture run for about a day, and then I ran the JA3 python script on the capture file to generate the aforementioned hashes.  Even though the capture file was only 39MB, it took the script a while to process all of the packets.  At some point, I&#39;d like to take a closer look at the script and see if there are any opportunities for optimization.  In order to make my life easier, I did add a JSON output option and submit a Pull Request.  Once I had my fingerprints, I compared them against a list that the trisul folks generated in late June from fingerprint strings that Lee Brotherston generated in late March.  Anyway, the point is that these fingerprints are not that recent - and it showed.  Of 82 unique fingerprints that were captured in my network, seven of them appeared in the trisul list.  None of the seven were Chrome which makes sense given the high release cadence that the Chrome team maintains.  I am curious what is lurking in those 75 remaining hashes.  My Nest?  Angry Birds?  Jinyang&#39;s fridge? So, the first thought I have is that for JA3 to be useful in a whitelisting approach, there is going to have to be a trusted source of fingerprints that is constantly profiling new versions of popular clients and generating fingerprints for them.  It would be nice to have a process that could monitor for new versions of applications like Chrome and Firefox, automatically pull them down, and generate signatures for them.  The second thought I had is that there might be less unique fingerprints to deal with in an enterprise setting (depending on how locked down the network is, of course) since there aren&#39;t going to be a bunch of random devices phoning home and mobile apps being used. &lt;/body&gt;&lt;/html&gt;" />
<meta property="og:description" content="&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt; For a while now, I have wanted the ability to easily sniff my own packets.  Specifically, I&#39;ve wanted to be able to monitor all traffic entering and exiting my home network.  In the past, I&#39;ve turned old machines into transparent bridges and wired them in between my router and cable modem.  However, actually using these boxes was never quite as simple as I had hoped, and in the back of my mind I was always afraid that the bridge would be detected and hax0red.  I knew the easiest solution would be to upgrade from my army of cheap, unmanaged switches to a more expensive manged switch that supported port mirroring.  In July, I finally ordered a TP-Link switch that fit the bill.  I installed it the day it arrived, but I have not had a chance to try the more advanced features until this past weekend.  I figured I&#39;d use the opportunity to kick the tires on the JA3 SSL/TLS client fingerprinting scheme that some researchers at Salesforce have been working on. Out of the box, the switch has the IP address 192.168.0.1, so I had to put a machine on that network in order to configure the switch.  Word to the wise, updating the firmware reverts the switch&#39;s IP address to 192.168.0.1, so you may want to update before changing the IP.  Anyway, enabling port mirroring on the TP Link was straightforward, if inelegant (you get what you pay for).  One gotcha is that I had to select the mirroring port a second time before it &#39;stuck&#39; (see previous parenthetical note).  I mirrored the port that connects the switch to my router, and after some futzing with my Raspberry Pi&#39;s external USB network adapter and an ancient USB hub, I was in business: This setup is temporary and I hope to neaten it up at some point in the near future. JA3 parses client Hello SSL/TLS packets and extracts out fields to create a string that can be used to uniquely identify a client (a fingerprint).  Instead of passing around a potentially large string, an MD5 hash is calculated.  Since I only needed to capture Hello packets, I did a quick Google to find a tcpdump filter that would drop the rest of the traffic coming over the mirror port:  tcpdump -ni eth1 &quot;tcp port 443 and (tcp[((tcp[12] &amp; 0xf0) &gt;&gt; 2)] = 0x16)&quot; This filter actually grabs server Hellos too, but I can live with that for now.  I let the capture run for about a day, and then I ran the JA3 python script on the capture file to generate the aforementioned hashes.  Even though the capture file was only 39MB, it took the script a while to process all of the packets.  At some point, I&#39;d like to take a closer look at the script and see if there are any opportunities for optimization.  In order to make my life easier, I did add a JSON output option and submit a Pull Request.  Once I had my fingerprints, I compared them against a list that the trisul folks generated in late June from fingerprint strings that Lee Brotherston generated in late March.  Anyway, the point is that these fingerprints are not that recent - and it showed.  Of 82 unique fingerprints that were captured in my network, seven of them appeared in the trisul list.  None of the seven were Chrome which makes sense given the high release cadence that the Chrome team maintains.  I am curious what is lurking in those 75 remaining hashes.  My Nest?  Angry Birds?  Jinyang&#39;s fridge? So, the first thought I have is that for JA3 to be useful in a whitelisting approach, there is going to have to be a trusted source of fingerprints that is constantly profiling new versions of popular clients and generating fingerprints for them.  It would be nice to have a process that could monitor for new versions of applications like Chrome and Firefox, automatically pull them down, and generate signatures for them.  The second thought I had is that there might be less unique fingerprints to deal with in an enterprise setting (depending on how locked down the network is, of course) since there aren&#39;t going to be a bunch of random devices phoning home and mobile apps being used. &lt;/body&gt;&lt;/html&gt;" />
<link rel="canonical" href="http://0.0.0.0:4000/2017/08/08/creating-a-home-testbed-and-kicking-the-tires-on-ja3.html" />
<meta property="og:url" content="http://0.0.0.0:4000/2017/08/08/creating-a-home-testbed-and-kicking-the-tires-on-ja3.html" />
<meta property="og:site_name" content="Ryan Persaud’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-08T03:36:27+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Creating a Home Testbed, and Kicking the Tires on JA3" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-08-08T03:36:27+00:00","datePublished":"2017-08-08T03:36:27+00:00","description":"&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt; For a while now, I have wanted the ability to easily sniff my own packets.  Specifically, I&#39;ve wanted to be able to monitor all traffic entering and exiting my home network.  In the past, I&#39;ve turned old machines into transparent bridges and wired them in between my router and cable modem.  However, actually using these boxes was never quite as simple as I had hoped, and in the back of my mind I was always afraid that the bridge would be detected and hax0red.  I knew the easiest solution would be to upgrade from my army of cheap, unmanaged switches to a more expensive manged switch that supported port mirroring.  In July, I finally ordered a TP-Link switch that fit the bill.  I installed it the day it arrived, but I have not had a chance to try the more advanced features until this past weekend.  I figured I&#39;d use the opportunity to kick the tires on the JA3 SSL/TLS client fingerprinting scheme that some researchers at Salesforce have been working on. Out of the box, the switch has the IP address 192.168.0.1, so I had to put a machine on that network in order to configure the switch.  Word to the wise, updating the firmware reverts the switch&#39;s IP address to 192.168.0.1, so you may want to update before changing the IP.  Anyway, enabling port mirroring on the TP Link was straightforward, if inelegant (you get what you pay for).  One gotcha is that I had to select the mirroring port a second time before it &#39;stuck&#39; (see previous parenthetical note).  I mirrored the port that connects the switch to my router, and after some futzing with my Raspberry Pi&#39;s external USB network adapter and an ancient USB hub, I was in business: This setup is temporary and I hope to neaten it up at some point in the near future. JA3 parses client Hello SSL/TLS packets and extracts out fields to create a string that can be used to uniquely identify a client (a fingerprint).  Instead of passing around a potentially large string, an MD5 hash is calculated.  Since I only needed to capture Hello packets, I did a quick Google to find a tcpdump filter that would drop the rest of the traffic coming over the mirror port:  tcpdump -ni eth1 &quot;tcp port 443 and (tcp[((tcp[12] &amp; 0xf0) &gt;&gt; 2)] = 0x16)&quot; This filter actually grabs server Hellos too, but I can live with that for now.  I let the capture run for about a day, and then I ran the JA3 python script on the capture file to generate the aforementioned hashes.  Even though the capture file was only 39MB, it took the script a while to process all of the packets.  At some point, I&#39;d like to take a closer look at the script and see if there are any opportunities for optimization.  In order to make my life easier, I did add a JSON output option and submit a Pull Request.  Once I had my fingerprints, I compared them against a list that the trisul folks generated in late June from fingerprint strings that Lee Brotherston generated in late March.  Anyway, the point is that these fingerprints are not that recent - and it showed.  Of 82 unique fingerprints that were captured in my network, seven of them appeared in the trisul list.  None of the seven were Chrome which makes sense given the high release cadence that the Chrome team maintains.  I am curious what is lurking in those 75 remaining hashes.  My Nest?  Angry Birds?  Jinyang&#39;s fridge? So, the first thought I have is that for JA3 to be useful in a whitelisting approach, there is going to have to be a trusted source of fingerprints that is constantly profiling new versions of popular clients and generating fingerprints for them.  It would be nice to have a process that could monitor for new versions of applications like Chrome and Firefox, automatically pull them down, and generate signatures for them.  The second thought I had is that there might be less unique fingerprints to deal with in an enterprise setting (depending on how locked down the network is, of course) since there aren&#39;t going to be a bunch of random devices phoning home and mobile apps being used. &lt;/body&gt;&lt;/html&gt;","headline":"Creating a Home Testbed, and Kicking the Tires on JA3","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/2017/08/08/creating-a-home-testbed-and-kicking-the-tires-on-ja3.html"},"url":"http://0.0.0.0:4000/2017/08/08/creating-a-home-testbed-and-kicking-the-tires-on-ja3.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="Ryan Persaud&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Ryan Persaud&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Creating a Home Testbed, and Kicking the Tires on JA3</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-08-08T03:36:27+00:00" itemprop="datePublished">Aug 8, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body>
<p>For a while now, I have wanted the ability to easily sniff my own packets.  Specifically, I've wanted to be able to monitor all traffic entering and exiting my home network.  In the past, I've turned old machines into transparent bridges and wired them in between my router and cable modem.  However, actually using these boxes was never quite as simple as I had hoped, and in the back of my mind I was always afraid that the bridge would be detected and hax0red.  I knew the easiest solution would be to upgrade from my army of cheap, unmanaged switches to a more expensive manged switch that supported port mirroring.  In July, I finally ordered a <a href="https://www.amazon.com/TP-Link-24-Port-Gigabit-Ethernet-TL-SG1024DE/dp/B00CUG8ESM">TP-Link switch</a> that fit the bill.  I installed it the day it arrived, but I have not had a chance to try the more advanced features until this past weekend.  I figured I'd use the opportunity to kick the tires on the JA3 <a href="https://engineering.salesforce.com/open-sourcing-ja3-92c9e53c3c41">SSL/TLS client fingerprinting scheme</a> that some researchers at Salesforce have been working on.</p>
<p>Out of the box, the switch has the IP address 192.168.0.1, so I had to put a machine on that network in order to configure the switch.  Word to the wise, updating the firmware reverts the switch's IP address to 192.168.0.1, so you may want to update before changing the IP.  Anyway, <a href="http://www.tp-link.com/us/faq-527.html">enabling port mirroring</a> on the TP Link was straightforward, if inelegant (you get what you pay for).  One gotcha is that I had to select the mirroring port a second time before it 'stuck' (see previous parenthetical note).  I mirrored the port that connects the switch to my router, and after some futzing with my Raspberry Pi's external USB network adapter and an ancient USB hub, I was in business:</p>
<p><figure><img src="/assets/images/sniffer.jpeg?w=300" alt="" width="300" height="225"><figcaption>This setup is temporary and I hope to neaten it up at some point in the near future.</figcaption></figure></p>
<p>JA3 parses client Hello SSL/TLS packets and extracts out fields to create a string that can be used to uniquely identify a client (a fingerprint).  Instead of passing around a potentially large string, an MD5 hash is calculated.  Since I only needed to capture Hello packets, I did a quick Google to find a tcpdump filter that would drop the rest of the traffic coming over the mirror port:  <code>tcpdump -ni eth1 "tcp port 443 and (tcp[((tcp[12] &amp; 0xf0) &gt;&gt; 2)] = 0x16)"</code></p>
<p>This filter actually grabs server Hellos too, but I can live with that for now.  I let the capture run for about a day, and then I ran the <a href="https://github.com/salesforce/ja3/tree/master/python">JA3 python script</a> on the capture file to generate the aforementioned hashes.  Even though the capture file was only 39MB, it took the script a while to process all of the packets.  At some point, I'd like to take a closer look at the script and see if there are any opportunities for optimization.  In order to make my life easier, I did add a JSON output option and submit a <a href="https://github.com/salesforce/ja3/pull/5">Pull Request</a>.  Once I had my fingerprints, I compared them against <a href="https://github.com/trisulnsm/trisul-scripts/blob/master/lua/frontend_scripts/reassembly/ja3/prints/ja3fingerprint.json">a list that the trisul folks generated in late June</a> from <a href="https://github.com/LeeBrotherston/tls-fingerprinting/blob/master/fingerprints/fingerprints.json">fingerprint strings</a> that Lee Brotherston generated in late March.  Anyway, the point is that these fingerprints are not that recent - and it showed.  Of 82 unique fingerprints that were captured in my network, seven of them appeared in the trisul list.  None of the seven were Chrome which makes sense given the high release cadence that the Chrome team maintains.  I am curious what is lurking in those 75 remaining hashes.  My Nest?  Angry Birds?  Jinyang's fridge?</p>
<p>So, the first thought I have is that for JA3 to be useful in a whitelisting approach, there is going to have to be a trusted source of fingerprints that is constantly profiling new versions of popular clients and generating fingerprints for them.  It would be nice to have a process that could monitor for new versions of applications like Chrome and Firefox, automatically pull them down, and generate signatures for them.  The second thought I had is that there might be less unique fingerprints to deal with in an enterprise setting (depending on how locked down the network is, of course) since there aren't going to be a bunch of random devices phoning home and mobile apps being used.</p>
<p></body></html></p>

  </div><a class="u-url" href="/2017/08/08/creating-a-home-testbed-and-kicking-the-tires-on-ja3.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ryan Persaud&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ryan Persaud&#39;s blog</li><li><a class="u-email" href="mailto:ryan.persaud At Google's Email Service">ryan.persaud At Google's Email Service</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ryanpersaud"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ryanpersaud</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is apparently where all of my musings have ended up.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
